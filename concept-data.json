{
    "concepts": [
        {
            "name": "Counting Sort",
            "category": "Pattern-Level Summary",
            "whatItIs": "A non-comparison sorting algorithm that counts how many times each value appears and then reconstructs the sorted array using those counts.",
            "whenToUse": [
                "When the values fall within a small, known range (e.g., only 0 and 1, or values up to a few hundred).",
                "When sorting binary arrays by counting zeros and filling the array with zeros then ones."
            ],
            "coreLoop": "let zeroCount = 0;\n\nfor (let n of nums) {\n    if (n === 0) {\n        zeroCount++;\n    }\n}\n\nfor (let i = 0; i < nums.length; i++) {\n    if (i < zeroCount) {\n        nums[i] = 0;\n    } else {\n        nums[i] = 1;\n    }\n}\n\nreturn nums;",
            "bigIdea": "Instead of comparing values (like in quicksort or mergesort), you sort by frequency."
        },
        {
            "name": "Set Membership Loop Pattern",
            "category": "LeetCode 2154 and many others",
            "whatItIs": "A pattern where you place all input values into a Set for O(1) membership checks, then repeatedly apply a transformation to a value as long as it exists in the set.",
            "whenToUse": [
                "When problems say things like: 'While x exists in the list...', 'Keep doubling/halving/transforming x...', or 'Repeat until the value disappears...'.",
                "When repeated membership checking would otherwise require nums.includes(x) (O(n)), nested loops, or manual scans."
            ],
            "coreLoop": "const seen = new Set(nums);\n\nwhile (seen.has(value)) {\n    value = transform(value);\n}",
            "bigIdea": "Use a Set to reduce repeated membership checks from O(n) to O(1) and pair it with a while loop to handle repeated transformations."
        }
    ]
}