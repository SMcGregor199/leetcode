{
    "concepts": [
        {
            "name": "Counting Sort",
            "category": "Algorithm",
            "whatItIs": "A non-comparison sorting algorithm that counts how many times each value appears and then reconstructs the sorted array using those counts.",
            "whenToUse": [
                "When the values fall within a small, known range (e.g., only 0 and 1, or values up to a few hundred).",
                "When sorting binary arrays by counting zeros and filling the array with zeros then ones."
            ],
            "corePattern": "",
            "coreLoop": "let zeroCount = 0;\n\nfor (let n of nums) {\n    if (n === 0) zeroCount++;\n}\n\nfor (let i = 0; i < nums.length; i++) {\n    nums[i] = i < zeroCount ? 0 : 1;\n}\n\nreturn nums;",
            "bigIdea": "Instead of comparing values (like in quicksort or mergesort), you sort by frequency."
        },
        {
            "name": "Set Membership Loop Pattern",
            "category": "Hashing / O(1) Lookup Patterns",
            "whatItIs": "A pattern where you place all input values into a Set for constant-time membership checks, then repeatedly apply a transformation to a value as long as it exists in the set.",
            "whenToUse": [
                "When problems say things like: 'While x exists in the list...'",
                "When repeated membership checking would otherwise require O(n) or nested loops."
            ],
            "corePattern": "",
            "coreLoop": "const seen = new Set(nums);\n\nwhile (seen.has(value)) {\n    value = transform(value);\n}",
            "bigIdea": "Use a Set to convert repeated existence checks from O(n) to O(1) and pair it with a loop that evolves a value until it no longer appears."
        },
        {
            "name": "Valid Window Substring Counting",
            "category": "Sliding Window Pattern",
            "whatItIs": "A sliding-window technique that counts how many substrings satisfy a constraint without generating them. The window expands to the right, shrinks from the left until valid, and once valid, every substring ending at right and starting between left and right is guaranteed valid.",
            "whenToUse": [
                "When counting substrings or subarrays that must satisfy a frequency or sum constraint.",
                "When a problem includes phrasing such as: 'Count the number of substrings where...'",
                "When shrinking a window cannot make it more invalid."
            ],
            "corePattern": "",
            "coreLoop": "let left = 0;\nlet ans = 0;\n\nfor (let right = 0; right < s.length; right++) {\n    include(s[right]); // update counts or sums\n\n    while (windowIsInvalid()) {\n        remove(s[left]); // undo contribution\n        left++;\n    }\n\n    ans += right - left + 1;\n}",
            "bigIdea": "If the window [left, right] is valid, every smaller substring ending at right is also valid."
        }
    ]
}